{
  "projects": [
    {
      "id": 1078684277,
      "name": "xjz-website",
      "full_name": "xjz6626/xjz-website",
      "description": "基于Rust + Axum构建的个人网站",
      "html_url": "https://github.com/xjz6626/xjz-website",
      "language": "HTML",
      "stargazers_count": 0,
      "forks_count": 0,
      "updated_at": "2025-10-18T07:54:02Z",
      "created_at": "2025-10-18T07:39:51Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 0,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1077390663,
      "name": "E2000-memo",
      "full_name": "xjz6626/E2000-memo",
      "description": "本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及串口调试工具。请在操作前仔细阅读本说明。",
      "html_url": "https://github.com/xjz6626/E2000-memo",
      "language": null,
      "stargazers_count": 0,
      "forks_count": 0,
      "updated_at": "2025-10-18T05:29:53Z",
      "created_at": "2025-10-16T07:31:23Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 852,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1076785117,
      "name": "VideoSubtitleScreenshotStitcher",
      "full_name": "xjz6626/VideoSubtitleScreenshotStitcher",
      "description": "这是一个智能的自动化工具，它通过快捷键启动，能够实时监控视频的字幕变化，并自动将包含新字幕的画面拼接成一张长图。项目使用 `EasyOCR` 进行文字识别，确保了截图的准确性，避免了重复和遗漏。",
      "html_url": "https://github.com/xjz6626/VideoSubtitleScreenshotStitcher",
      "language": "Python",
      "stargazers_count": 0,
      "forks_count": 0,
      "updated_at": "2025-10-15T10:55:48Z",
      "created_at": "2025-10-15T10:42:58Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 10753,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1057826590,
      "name": "vxworks-script-utils",
      "full_name": "xjz6626/vxworks-script-utils",
      "description": "一套用于 VxWorks 项目的 Python 辅助脚本，能够自动化执行代码的构建、解析，并为 C 语言代码生成函数桩（stubs）。",
      "html_url": "https://github.com/xjz6626/vxworks-script-utils",
      "language": "Python",
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-09-16T09:07:44Z",
      "created_at": "2025-09-16T09:00:35Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 20,
      "default_branch": "master",
      "archived": false,
      "fork": false
    }
  ],
  "articles": [
    {
      "id": "xjz-website-DEPLOYMENT",
      "title": "Fedora + Cloudflare 部署指南",
      "content": "# Fedora + Cloudflare 部署指南\n\n## 环境要求\n\n- Fedora Server (推荐 Fedora 38+)\n- Rust 1.70+\n- Git\n- Cloudflare 账户\n\n## 服务器部署步骤\n\n### 1. 系统准备\n\n```bash\n# 更新系统\nsudo dnf update -y\n\n# 安装必要工具\nsudo dnf install -y git curl gcc openssl-devel pkg-config\n\n# 安装 Rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n```\n\n### 2. 克隆项目\n\n```bash\ngit clone https://github.com/xjz6626/xjz-website.git\ncd xjz-website\n```\n\n### 3. 构建生产版本\n\n```bash\ncargo build --release\n```\n\n### 4. 创建systemd服务\n\n```bash\nsudo tee /etc/systemd/system/xjz-website.service > /dev/null << 'EOF'\n[Unit]\nDescription=XJZ Personal Website\nAfter=network.target\n\n[Service]\nType=simple\nUser=fedora\nWorkingDirectory=/home/fedora/xjz-website\nEnvironment=RUST_LOG=info\nEnvironment=PORT=3000\nEnvironment=HOST=127.0.0.1\nExecStart=/home/fedora/xjz-website/target/release/xjz_website\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nEOF\n```\n\n### 5. 启动服务\n\n```bash\nsudo systemctl daemon-reload\nsudo systemctl enable xjz-website\nsudo systemctl start xjz-website\nsudo systemctl status xjz-website\n```\n\n### 6. 配置防火墙\n\n```bash\n# 开放端口（如果使用防火墙）\nsudo firewall-cmd --permanent --add-port=3000/tcp\nsudo firewall-cmd --reload\n\n# 或者允许HTTP/HTTPS（推荐通过反向代理）\nsudo firewall-cmd --permanent --add-service=http\nsudo firewall-cmd --permanent --add-service=https\nsudo firewall-cmd --reload\n```\n\n## Cloudflare 配置\n\n### 1. 域名配置\n\n1. 登录 [Cloudflare Dashboard](https://dash.cloudflare.com)\n2. 添加你的域名\n3. 按照提示更改域名服务器到Cloudflare\n\n### 2. DNS 记录配置\n\n添加以下DNS记录：\n\n```\n类型: A\n名称: @（或你的子域名）\n内容: 你的服务器IP地址\n代理状态: 已代理（橙色云朵）\nTTL: 自动\n```\n\n如果使用子域名：\n```\n类型: A\n名称: www\n内容: 你的服务器IP地址\n代理状态: 已代理（橙色云朵）\n```\n\n### 3. SSL/TLS 配置\n\n1. 进入 `SSL/TLS` > `概述`\n2. 选择加密模式：`灵活` 或 `完全`\n3. 进入 `边缘证书`\n4. 开启 `始终使用HTTPS`\n5. 开启 `HSTS`\n\n### 4. 性能优化\n\n进入 `速度` 页面：\n- 开启 `自动缩小`（CSS、HTML、JavaScript）\n- 开启 `Brotli` 压缩\n- 开启 `火箭加载器`（可选）\n\n### 5. 页面规则（可选）\n\n创建页面规则来优化缓存：\n\n```\nURL: yourdomain.com/public/*\n设置:\n- 缓存级别: 缓存所有内容\n- 边缘缓存TTL: 1个月\n```\n\n```\nURL: yourdomain.com/api/*\n设置:\n- 缓存级别: 绕过\n```\n\n## 安全配置\n\n### 1. Cloudflare 安全设置\n\n进入 `安全性` 页面：\n- 设置安全级别：`中` 或 `高`\n- 开启 `机器人斗争模式`（可选）\n- 配置 `速率限制`（可选）\n\n### 2. 防火墙规则\n\n创建防火墙规则只允许Cloudflare IP访问：\n\n```bash\n# 获取Cloudflare IP列表并配置防火墙（可选）\ncurl -s https://www.cloudflare.com/ips-v4 | while read ip; do\n    sudo firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='$ip' port protocol='tcp' port='3000' accept\"\ndone\n\nsudo firewall-cmd --reload\n```\n\n## 监控和维护\n\n### 1. 查看日志\n\n```bash\n# 查看应用日志\nsudo journalctl -u xjz-website -f\n\n# 查看系统日志\nsudo journalctl -xe\n```\n\n### 2. 更新部署\n\n```bash\ncd /home/fedora/xjz-website\ngit pull origin main\ncargo build --release\nsudo systemctl restart xjz-website\n```\n\n### 3. 监控服务状态\n\n```bash\n# 检查服务状态\nsudo systemctl status xjz-website\n\n# 检查端口监听\nsudo ss -tlnp | grep :3000\n\n# 检查进程\nps aux | grep xjz_website\n```\n\n## 故障排除\n\n### 应用无法启动\n```bash\n# 检查编译错误\ncargo build --release\n\n# 检查权限\nsudo chown -R fedora:fedora /home/fedora/xjz-website\n\n# 检查日志\nsudo journalctl -u xjz-website --no-pager\n```\n\n### Cloudflare 问题\n- 检查DNS解析：`dig yourdomain.com`\n- 验证SSL证书：浏览器访问 `https://yourdomain.com`\n- 清除Cloudflare缓存：Dashboard > 缓存 > 清除所有内容\n\n### 性能优化\n- 启用 Cloudflare 的 `Argo Smart Routing`\n- 配置 `缓存规则` 提高静态资源缓存\n- 使用 `Cloudflare Analytics` 监控性能\n\n## 备份策略\n\n```bash\n# 创建备份脚本\ncat > /home/fedora/backup.sh << 'EOF'\n#!/bin/bash\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_DIR=\"/home/fedora/backups\"\nmkdir -p $BACKUP_DIR\n\n# 备份应用目录\ntar -czf $BACKUP_DIR/xjz-website_$DATE.tar.gz /home/fedora/xjz-website\n\n# 保留最近7天的备份\nfind $BACKUP_DIR -name \"xjz-website_*.tar.gz\" -mtime +7 -delete\nEOF\n\nchmod +x /home/fedora/backup.sh\n\n# 添加到定时任务（每天凌晨2点备份）\necho \"0 2 * * * /home/fedora/backup.sh\" | crontab -\n```",
      "excerpt": "- Fedora Server (推荐 Fedora 38+) - Rust 1.70+ - Git",
      "file_path": "DEPLOYMENT.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/DEPLOYMENT.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-18T07:54:02Z",
      "file_size": 4783,
      "reading_time": 14,
      "category": "Web开发",
      "tags": [
        "JavaScript",
        "Rust",
        "Web"
      ],
      "featured": true
    },
    {
      "id": "xjz-website-DEVELOPMENT",
      "title": "开发记录",
      "content": "# 开发记录\n\n## 项目概述\n\nXJZ个人网站 - 基于Rust + Axum构建的高性能个人网站系统\n\n## 开发历程\n\n### 2024-10-18\n\n#### 初始化项目\n- 创建Rust Axum项目结构\n- 设计基础路由系统\n- 实现静态文件服务\n\n#### GitHub API集成\n- 实现GitHub客户端 (`src/github/client.rs`)\n- 设计数据模型 (`src/github/models.rs`)\n- 创建数据管理器 (`src/github/manager.rs`)\n- 支持项目、文章、统计数据获取\n\n#### 前端模板系统\n- 使用Askama模板引擎\n- 创建响应式布局 (`templates/base.html`)\n- 实现各页面模板：\n  - `index.html` - 主页\n  - `projects.html` - 项目展示\n  - `blog.html` - 博客文章\n  - `about.html` - 个人介绍\n  - `resume.html` - 简历\n  - `contact.html` - 联系方式\n\n#### 动态数据系统\n- 实现API端点：\n  - `/api/projects` - 项目数据\n  - `/api/articles` - 文章数据\n  - `/api/stats` - 统计数据\n- 前端JavaScript类：\n  - `HomeProjectLoader` - 主页项目加载\n  - `GitHubProjectLoader` - 项目页面加载\n  - `BlogLoader` - 博客文章加载\n\n#### 前端优化\n- 替换所有硬编码静态内容为动态API数据\n- 优化CSS样式系统\n- 添加加载状态和错误处理\n- 实现响应式设计\n\n## 技术特点\n\n### 后端架构\n- **框架**: Axum (高性能异步Web框架)\n- **HTTP客户端**: Reqwest (异步HTTP请求)\n- **模板引擎**: Askama (编译时模板)\n- **序列化**: Serde (JSON处理)\n- **异步运行时**: Tokio\n\n### 前端特性\n- **纯HTML/CSS/JS**: 无框架依赖\n- **响应式设计**: 支持多设备\n- **动态加载**: API驱动的内容更新\n- **性能优化**: 最小化网络请求\n\n### API设计\n- RESTful API设计\n- JSON数据格式\n- 错误处理和状态码\n- 缓存友好的响应头\n\n## 代码质量\n\n### 错误处理\n- 统一的错误类型系统\n- API错误的优雅降级\n- 前端错误状态显示\n\n### 性能优化\n- 异步I/O操作\n- 静态文件缓存\n- 最小化API调用\n\n### 可维护性\n- 模块化代码结构\n- 清晰的职责分离\n- 文档化的API接口\n\n## 部署准备\n\n### 生产优化\n- Release模式编译\n- 静态资源压缩\n- 环境变量配置\n\n### 服务器要求\n- Linux环境\n- Rust编译环境\n- 反向代理(Nginx)\n- SSL证书支持\n\n## 未来改进\n\n### 功能扩展\n- [ ] 评论系统\n- [ ] 搜索功能\n- [ ] RSS订阅\n- [ ] 多语言支持\n\n### 性能优化\n- [ ] Redis缓存\n- [ ] CDN集成\n- [ ] 图片优化\n- [ ] PWA支持\n\n### 监控运维\n- [ ] 日志系统\n- [ ] 监控指标\n- [ ] 自动部署\n- [ ] 备份策略",
      "excerpt": "XJZ个人网站 - 基于Rust + Axum构建的高性能个人网站系统 - 创建Rust Axum项目结构 - 设计基础路由系统",
      "file_path": "DEVELOPMENT.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/DEVELOPMENT.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-18T07:54:02Z",
      "file_size": 2529,
      "reading_time": 6,
      "category": "Web开发",
      "tags": [
        "JavaScript",
        "Rust",
        "Web"
      ],
      "featured": true
    },
    {
      "id": "xjz-website-GITHUB_SETUP",
      "title": "GitHub API 配置说明",
      "content": "# GitHub API 配置说明\n\n## 配置GitHub Personal Access Token\n\n### 步骤1: 创建GitHub Token\n\n1. 访问 https://github.com/settings/personal-access-tokens/tokens\n2. 点击 \"Generate new token (classic)\"\n3. 设置名称：比如 \"xjz_website_api\"\n4. 选择权限（scopes）：\n   - ✅ `public_repo` - 访问公开仓库\n   - ✅ `read:user` - 读取用户信息\n5. 点击 \"Generate token\"\n6. **重要**：复制生成的token（只显示一次）\n\n### 步骤2: 配置Token\n\n在 `src/github/config.rs` 文件中，找到这一行：\n```rust\nlet hardcoded_token = \"YOUR_TOKEN_HERE\";\n```\n\n将 `\"YOUR_TOKEN_HERE\"` 替换为你刚才复制的token：\n```rust\nlet hardcoded_token = \"ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n```\n\n### 步骤3: 重启服务器\n\n```bash\ncargo run\n```\n\n启动时你会看到配置状态：\n```\n=== GitHub配置状态 ===\n用户名: xjz6626\nToken: 已配置 ✅\nAPI限制: 5000次/小时\n=====================\n```\n\n## API 限制对比\n\n- **无token**: 60次/小时\n- **有token**: 5000次/小时\n\n## 验证配置\n\n配置完成后，测试API：\n```bash\ncurl http://127.0.0.1:3000/api/update\ncurl http://127.0.0.1:3000/api/stats\n```\n\n应该能看到正确的项目数据而不是错误信息。",
      "excerpt": "1. 访问 https://github.com/settings/personal-access-tokens/tokens 2. 点击 \"Generate new token (classic)\" 3. 设置名称：比如 \"xjz_website_api...",
      "file_path": "GITHUB_SETUP.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/GITHUB_SETUP.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-18T07:54:02Z",
      "file_size": 1223,
      "reading_time": 3,
      "category": "Web开发",
      "tags": [
        "Rust",
        "Web"
      ],
      "featured": false
    },
    {
      "id": "E2000-memo-Arch Linux 嵌入式开发环境配置备忘录",
      "title": "**Arch Linux 嵌入式开发环境配置备忘录**",
      "content": "# **Arch Linux 嵌入式开发环境配置备忘录**\n\n本文档记录了从零开始，在 Arch Linux 主机上配置连接嵌入式开发板（E2000-Ubuntu）并共享网络的完整调试流程。\n\n## **第一部分：串口连接调试 (Serial Port)**\n\n目标：通过 minicom 或 picocom 等工具，成功通过串口连接到开发板的控制台。\n\n### **1.1 安装串口工具**\n\n\\# 安装经典的 minicom  \nsudo pacman \\-S minicom\n\n\\# 安装轻量级的 picocom (推荐)  \nsudo pacman \\-S picocom\n\n### **1.2 解决串口权限问题**\n\n直接连接通常会失败，提示 Permission denied。\n\n#### **1.2.1 确认设备名和用户组**\n\n首先，插入USB转串口设备，然后用 dmesg 查找设备名。\n\ndmesg | grep tty  \n\\# 输出通常会包含 ttyUSB0 或 ttyACM0\n\n接着，查看设备文件的权限。\n\nls \\-l /dev/ttyUSB0  \n\\# crw-rw---- 1 root uucp ...\n\n**关键点**：注意上面的用户组是 uucp。在很多其他发行版中是 dialout，但在我们的 Arch 系统上是 uucp。这意味着我们的用户需要被添加到 uucp 组。\n\n#### **1.2.2 将用户添加到 uucp 组**\n\n\\# 将当前用户添加到 uucp 组  \nsudo usermod \\-a \\-G uucp $USER\n\n**重要**：执行此命令后，必须**完全注销并重新登录**桌面环境，新的用户组权限才会生效。\n\n### **1.3 成功连接**\n\n完成权限配置后，使用 picocom 连接。\n\npicocom \\--baud 115200 /dev/ttyUSB0\n\n* **退出 Picocom**: 按 Ctrl+A 然后按 Ctrl+X。\n\n## **第二部分：共享主机网络给开发板**\n\n目标：让 Arch 主机通过 Wi-Fi 上网，然后通过有线网口将网络共享给开发板。\n\n### **2.1 识别网卡硬件与驱动问题**\n\n首先发现图形化网络设置中没有“有线连接”选项。\n\n#### **2.1.1 检查系统网络接口**\n\nip link show 命令的输出中没有 eth0 或 enp... 等有线网卡设备。\n\n#### **2.1.2 识别硬件型号**\n\n使用 lspci 查找硬件，发现系统未能加载驱动。\n\nlspci \\-k | grep \\-i ethernet \\-A 3  \n\\# 输出显示:  \n\\# 02:00.0 Ethernet controller: Motorcomm Microelectronics. YT6801 Gigabit Ethernet Controller  \n\\# (并且该条目下没有 \"Kernel driver in use\" 字样)\n\n**结论**: 系统缺少 Motorcomm YT6801 网卡的驱动。\n\n### **2.2 从 AUR 安装驱动**\n\nArch Linux 的官方仓库没有这个驱动，需要从 AUR (Arch User Repository) 安装。\n\n#### **2.2.1 安装 AUR 助手 yay (若无)**\n\nsudo pacman \\-S \\--needed base-devel git  \ngit clone \\[https://aur.archlinux.org/yay.git\\](https://aur.archlinux.org/yay.git)  \ncd yay  \nmakepkg \\-si  \ncd .. \\# 返回上级目录\n\n#### **2.2.2 安装内核头文件**\n\n编译内核驱动需要对应版本的头文件。假设使用的是 zen 内核。\n\n\\# uname \\-r  (可查看当前内核版本)  \nsudo pacman \\-S linux-zen-headers \\# 根据你的内核版本选择，例如 linux-headers\n\n#### **2.2.3 安装 DKMS 驱动**\n\nyay \\-S yt6801-dkms\n\n#### **2.2.4 加载并验证驱动**\n\nsudo modprobe yt6801  \nip link show\n\n此时应该能看到 enp2s0 等有线网卡接口出现了。重启电脑是确保驱动正确加载的最稳妥方法。\n\n### **2.3 配置 NetworkManager 共享**\n\n#### **2.3.1 安装 dnsmasq 依赖**\n\nNetworkManager 的共享功能依赖 dnsmasq 来提供 DHCP 服务。\n\nsudo pacman \\-S dnsmasq\n\n#### **2.3.2 重启 NetworkManager**\n\nsudo systemctl restart NetworkManager\n\n#### **2.3.3 在图形界面设置共享**\n\n1. 用网线连接两台电脑。  \n2. 进入“设置” \\-\\> “网络”。  \n3. 此时“有线连接”应该已出现。点击其旁边的齿轮图标 ⚙。  \n4. 进入 “IPv4” 选项卡，将 “Method” 设置为 “**与其他计算机共享**”。  \n5. 点击“应用”。\n\n### **2.4 手动配置防火墙 (iptables)**\n\n此时客户端能获取 IP (10.42.0.x)，DNS也能通，但 ping 不通外网。这是因为缺少 NAT 转发规则。\n\n#### **2.4.1 开启内核 IP 转发**\n\n\\# 临时生效  \nsudo sysctl net.ipv4.ip\\_forward=1  \n\\# 永久生效  \necho 'net.ipv4.ip\\_forward \\= 1' | sudo tee /etc/sysctl.d/99-forwarding.conf\n\n#### **2.4.2 添加 iptables 规则**\n\n\\# 规则1：允许已建立的连接通过  \nsudo iptables \\-A FORWARD \\-m conntrack \\--ctstate RELATED,ESTABLISHED \\-j ACCEPT\n\n\\# 规则2：允许从共享网口到外网的新连接  \nsudo iptables \\-A FORWARD \\-i enp2s0 \\-o wlan0 \\-j ACCEPT\n\n\\# 规则3：设置NAT地址伪装  \nsudo iptables \\-t nat \\-A POSTROUTING \\-s 10.42.0.0/24 \\-o wlan0 \\-j MASQUERADE\n\n**注意**：-i enp2s0 是你的有线网卡名，-o wlan0 是你的 Wi-Fi 网卡名。请根据 ip a 的实际输出进行调整。\n\n#### **2.4.3 永久保存 iptables 规则**\n\n\\# 安装用于保存规则的服务包 (安装时按 'y' 同意替换旧的 iptables)  \nsudo pacman \\-S iptables-nft\n\n\\# 保存当前生效的规则到文件  \nsudo iptables-save | sudo tee /etc/iptables/iptables.rules\n\n\\# 设置开机自启服务  \nsudo systemctl enable iptables.service\n\n## **第三部分：VS Code 远程 SSH 连接**\n\n目标：在 Arch 主机上使用 VS Code，通过 SSH 远程开发 E2000 板子。\n\n### **3.1 安装主机 SSH 客户端**\n\nVS Code 需要使用系统的 ssh 命令。\n\n\\# openssh 包同时提供了客户端和服务端  \nsudo pacman \\-S openssh\n\n### **3.2 安装 VS Code 扩展**\n\n在 VS Code 的扩展商店中，搜索并安装由 Microsoft 官方发布的 **Remote \\- SSH** 扩展。\n\n### **3.3 连接步骤**\n\n1. 点击 VS Code 左下角的绿色 \\>\\< 图标。  \n2. 选择 “Connect to Host...”。  \n3. 选择 “+ Add New SSH Host...”。  \n4. 输入连接命令：ssh root@10.42.0.102。  \n5. 选择默认的 SSH 配置文件保存。  \n6. 点击 “Connect”，在弹出的窗口中输入 root 用户的密码。  \n7. 连接成功后，左下角会显示 SSH: 10.42.0.102。\n\n至此，整个开发环境配置完成。",
      "excerpt": "本文档记录了从零开始，在 Arch Linux 主机上配置连接嵌入式开发板（E2000-Ubuntu）并共享网络的完整调试流程。 目...",
      "file_path": "Arch Linux 嵌入式开发环境配置备忘录.md",
      "file_url": "https://github.com/xjz6626/E2000-memo/blob/main/Arch Linux 嵌入式开发环境配置备忘录.md",
      "repo_name": "E2000-memo",
      "repo_url": "https://github.com/xjz6626/E2000-memo",
      "updated_at": "2025-10-18T05:29:53Z",
      "file_size": 5825,
      "reading_time": 14,
      "category": "技术文档",
      "tags": [],
      "featured": true
    },
    {
      "id": "E2000-memo-主板硬件连接说明文档",
      "title": "**主板硬件连接说明文档**",
      "content": "# **主板硬件连接说明文档**\n\n## **1\\. 概述**\n\n本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及串口调试工具。请在操作前仔细阅读本说明。\n\n## **2\\. 硬件接口总览**\n\n### **2.1 后置I/O接口**\n\n* **电源接口 (DC IN):** 用于连接电源适配器，为主板供电。  \n* **串口 (COM):** 两个标准的DB9公头串口，用于连接外部串口设备。  \n* **VGA接口:** 模拟视频输出接口，用于连接显示器。  \n* **HDMI接口:** 高清多媒体接口，用于连接高清显示设备。  \n* **USB 2.0/3.0接口:** 用于连接键盘、鼠标、U盘等USB外设。  \n* **网口 (LAN):** RJ45以太网接口，用于连接有线网络。  \n* **音频接口:** 包括音频输出（绿色）和麦克风输入（粉色）。\n\n### **2.2 板载接口与按钮**\n\n* **开机键:** 位于主板右上角，用于启动或关闭主板电源。  \n* **J15串口排针:** 位于MicroSD卡槽旁，用于连接TTL串口调试线。\n\n## **3\\. 连接步骤**\n\n### **3.1 电源连接与开机**\n\n1. **连接电源适配器:** 将电源适配器的DC输出端插入主板后置I/O面板上的 **电源接口**。  \n2. **启动系统:** 按下主板右上角的 **开机键**，系统将开始启动。\n\n### **3.2 串口调试连接 (适用于开发者)**\n\n此步骤用于底层系统调试，普通用户可跳过。\n\n1. **识别线序:**  \n   * **主板端:** 找到J15排针。  \n   * **USB转TTL模块端:** 识别GND (地)、TXD (发送)、RXD (接收) 引脚。  \n2. **连接线缆:**  \n   * 将杜邦线的一端连接到主板的 **J15** 排针上。  \n   * 将杜邦线的另一端连接到USB转TTL模块。**务必确保线序交叉连接正确**，连接方式如下：  \n     * 主板的 **GND** \\<--\\> 模块的 **GND** (黑色线)  \n     * 主板的 **TXD** \\<--\\> 模块的 **RXD** (红色线)  \n     * 主板的 **RXD** \\<--\\> 模块的 **TXD** (棕色线)\n\n**注意:** 串口通信的原理是发送端(TX)连接接收端(RX)。如果连接后无法通信，请检查接线或尝试对调模块端的TXD和RXD接线。\n\n3. **连接至计算机并配置SecureCRT:**  \n   * 将USB转TTL模块插入计算机的USB端口，系统会自动识别COM端口。  \n   * 打开 **SecureCRT** 软件，创建一个新的Serial（串口）会话。  \n   * 在会话设置中，**Port** 会自动识别，**Baud rate** (波特率) 设置为 **115200**，其余配置项保持默认。  \n   * 连接会话后，即可开始进行串口调试。\n\n### **3.3 通过网络共享为开发板提供网络 (Windows)**\n\n此步骤用于将您Windows电脑的网络连接共享给开发板，使其能够访问互联网。\n\n1. **物理连接:**  \n   * 使用一根网线，将开发板的 **网口(LAN)** 与您Windows电脑的 **以太网口** 直接连接。  \n   * 确保您的Windows电脑已通过其他方式（如Wi-Fi或另一个以太网口）连接到互联网。  \n2. **打开网络连接设置:**  \n   * 在Windows上，按下 Win \\+ R 键打开“运行”对话框。  \n   * 输入 ncpa.cpl 并按回车，这将打开“网络连接”窗口。  \n3. **配置网络共享:**  \n   * 在“网络连接”窗口中，找到您电脑用于上网的网络适配器（例如，名为“WLAN”或“Wi-Fi”的无线网络连接）。  \n   * 右键单击该适配器，选择 **“属性”**。  \n   * 切换到 **“共享”** 选项卡。  \n   * 勾选 **“允许其他网络用户通过此计算机的Internet连接来连接”** 复选框。  \n   * 在 **“家庭网络连接”** 的下拉菜单中，选择连接到开发板的那个以太网适配器（例如，名为“以太网”）。  \n   * 点击 **“确定”** 保存设置。Windows会自动为连接开发板的那个以太网口配置IP地址（通常是192.168.137.1）。  \n4. **配置并验证开发板网络:**  \n   * 启动开发板，进入其操作系统（Ubuntu）。  \n   * 将网络设置为 **自动获取IP地址 (DHCP)**。  \n   * 在终端中执行以下命令查看获取到的IP地址：  \n     ip a\n\n     在返回的信息中，您应该能看到一个形如 192.168.137.x 的IP地址。  \n   * 执行以下命令测试网络是否可用：  \n     ping baidu.com\n\n     如果看到有连续的数据返回，说明开发板已成功通过您的电脑连接到互联网。\n\n### **3.4 使用 VS Code 通过 SSH 远程开发**\n\n此步骤让您可以在熟悉的 VS Code 环境中直接对开发板上的文件进行编辑、编译和调试。\n\n1. **确认开发板 SSH 服务状态:**  \n   * 首先需要确保开发板已连接到网络（参考 3.3 节）。  \n   * 开发板通常已预装 SSH 服务。您可以在开发板的 Ubuntu 终端中，执行以下命令来检查其运行状态：  \n     sudo systemctl status ssh\n\n   * 如果服务未运行，可以使用 sudo systemctl start ssh 命令启动它。  \n2. **在 VS Code 中安装 \"Remote \\- SSH\" 扩展:**  \n   * 在您的 Windows 电脑上打开 VS Code。  \n   * 点击左侧活动栏的 **扩展** 图标 (Extensions)。  \n   * 在搜索框中输入 Remote \\- SSH。  \n   * 找到由 Microsoft 发布的官方扩展并点击 **安装 (Install)**。  \n3. **配置 SSH 连接:**  \n   * 安装扩展后，左侧活动栏会出现一个新的 **远程资源管理器** 图标 (Remote Explorer)。点击它。  \n   * 在下拉菜单中确保选中了 \"SSH\"。  \n   * 点击 \"SSH\" 标题栏旁边的 **“+”** 加号图标（新建远程连接）。  \n   * 在弹出的输入框中，输入连接命令，格式为 ssh username@ip\\_address。  \n     * username 是您在开发板 Ubuntu 系统上的用户名。  \n     * ip\\_address 是您在上一步中通过 ip a 命令获取到的 IP 地址 (例如 192.168.137.58)。  \n     * 示例: ssh myuser@192.168.137.58  \n   * 按回车后，选择第一个推荐的 SSH 配置文件进行保存。  \n4. **连接到开发板:**  \n   * 配置完成后，您将在远程资源管理器的列表中看到新添加的开发板主机。  \n   * 将鼠标悬停在该主机上，然后点击右侧出现的 **连接到主机** 图标（一个文件夹带一个加号的图标）。  \n   * VS Code 将打开一个新窗口并尝试连接。首次连接时会询问目标系统的平台类型，选择 **Linux**。  \n   * 在弹出的输入框中，输入您在开发板上的用户密码。  \n   * 连接成功后，VS Code 左下角会显示 SSH: \\[ip\\_address\\]，表示您已成功连接。  \n5. **开始开发:**  \n   * 连接成功后，点击 **文件 (File) \\> 打开文件夹 (Open Folder...)**，您可以直接浏览并打开开发板上的任意项目文件夹，像在本地一样进行开发了。\n\n## **4\\. 常用命令**\n\n### **4.1 关机**\n\n在终端中执行以下命令可以安全地关闭系统：\n\npoweroff\n\n### **4.2 重启**\n\n在终端中执行以下命令可以重启系统：\n\nreboot\n\n## **5\\. 注意事项**\n\n1. **环境隔离:** 尽量在 Docker 容器下使用项目指定的软件版本进行开发和测试，以避免环境污染和版本冲突。  \n2. **安全操作:** 切勿在 root 用户下运行来源不明的脚本或程序，以防系统被恶意破坏或数据泄露。\n\n\n![alt text](5bbbbdadca37c4d8ce03fc3af55f9103_720.jpg)\n![alt text](7df655a509c9c7f4f3b2f3d6f4af25ac_720.jpg)\n![alt text](64b549c97d4cca18e9fc1ce5b897ba53_720.jpg)\n![alt text](6023fcde6108ddd394eaf99b0cab18ea_720.jpg)",
      "excerpt": "本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及...",
      "file_path": "主板硬件连接说明文档.md",
      "file_url": "https://github.com/xjz6626/E2000-memo/blob/main/主板硬件连接说明文档.md",
      "repo_name": "E2000-memo",
      "repo_url": "https://github.com/xjz6626/E2000-memo",
      "updated_at": "2025-10-18T05:29:53Z",
      "file_size": 7462,
      "reading_time": 15,
      "category": "技术文档",
      "tags": [],
      "featured": true
    }
  ],
  "user_stats": {
    "username": "xjz6626",
    "total_repos": 4,
    "total_stars": 0,
    "total_forks": 0,
    "followers": 0,
    "following": 1,
    "public_gists": 0,
    "avatar_url": "https://avatars.githubusercontent.com/u/95295959?v=4",
    "bio": null,
    "location": null,
    "blog": "",
    "company": null,
    "created_at": "2021-11-30T14:18:28Z",
    "updated_at": "2025-10-17T12:54:41Z"
  },
  "language_stats": null,
  "last_updated": "2025-10-18T08:23:45.374092777Z",
  "next_update": "2025-10-21T08:23:45.374092777Z"
}