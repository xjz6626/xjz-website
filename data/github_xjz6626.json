{
  "projects": [
    {
      "id": 1078684277,
      "name": "xjz-website",
      "full_name": "xjz6626/xjz-website",
      "description": "基于Rust + Axum构建的个人网站",
      "html_url": "https://github.com/xjz6626/xjz-website",
      "language": "HTML",
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-10-27T07:04:22Z",
      "created_at": "2025-10-18T07:39:51Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 130,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1081114605,
      "name": "bangmi",
      "full_name": "xjz6626/bangmi",
      "description": null,
      "html_url": "https://github.com/xjz6626/bangmi",
      "language": "Python",
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-10-24T03:19:18Z",
      "created_at": "2025-10-22T10:31:39Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 40,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1078717984,
      "name": "fedora-workstation-server-guide",
      "full_name": "xjz6626/fedora-workstation-server-guide",
      "description": "🚀 Fedora Workstation 服务器化配置终极指南 - 将笔记本电脑转变为7x24小时运行的个人服务器",
      "html_url": "https://github.com/xjz6626/fedora-workstation-server-guide",
      "language": null,
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-10-24T03:19:10Z",
      "created_at": "2025-10-18T09:16:18Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 12,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1077390663,
      "name": "E2000-memo",
      "full_name": "xjz6626/E2000-memo",
      "description": "本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及串口调试工具。请在操作前仔细阅读本说明。",
      "html_url": "https://github.com/xjz6626/E2000-memo",
      "language": null,
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-10-24T03:18:53Z",
      "created_at": "2025-10-16T07:31:23Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 852,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1076785117,
      "name": "VideoSubtitleScreenshotStitcher",
      "full_name": "xjz6626/VideoSubtitleScreenshotStitcher",
      "description": "这是一个智能的自动化工具，它通过快捷键启动，能够实时监控视频的字幕变化，并自动将包含新字幕的画面拼接成一张长图。项目使用 `EasyOCR` 进行文字识别，确保了截图的准确性，避免了重复和遗漏。",
      "html_url": "https://github.com/xjz6626/VideoSubtitleScreenshotStitcher",
      "language": "Python",
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-10-24T03:18:44Z",
      "created_at": "2025-10-15T10:42:58Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 10753,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1081677931,
      "name": "bilibili_up_monitor",
      "full_name": "xjz6626/bilibili_up_monitor",
      "description": null,
      "html_url": "https://github.com/xjz6626/bilibili_up_monitor",
      "language": "Python",
      "stargazers_count": 0,
      "forks_count": 0,
      "updated_at": "2025-10-23T06:08:52Z",
      "created_at": "2025-10-23T06:08:46Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 13,
      "default_branch": "main",
      "archived": false,
      "fork": false
    },
    {
      "id": 1057826590,
      "name": "vxworks-script-utils",
      "full_name": "xjz6626/vxworks-script-utils",
      "description": "一套用于 VxWorks 项目的 Python 辅助脚本，能够自动化执行代码的构建、解析，并为 C 语言代码生成函数桩（stubs）。",
      "html_url": "https://github.com/xjz6626/vxworks-script-utils",
      "language": "Python",
      "stargazers_count": 1,
      "forks_count": 0,
      "updated_at": "2025-09-16T09:07:44Z",
      "created_at": "2025-09-16T09:00:35Z",
      "topics": [],
      "open_issues_count": 0,
      "size": 20,
      "default_branch": "master",
      "archived": false,
      "fork": false
    }
  ],
  "articles": [
    {
      "id": "xjz-website-DEPLOYMENT",
      "title": "Fedora + Cloudflare 部署指南",
      "content": "# Fedora + Cloudflare 部署指南\n\n## 环境要求\n\n- Fedora Server (推荐 Fedora 38+)\n- Rust 1.70+\n- Git\n- Cloudflare 账户\n\n## 服务器部署步骤\n\n### 1. 系统准备\n\n```bash\n# 更新系统\nsudo dnf update -y\n\n# 安装必要工具\nsudo dnf install -y git curl gcc openssl-devel pkg-config\n\n# 安装 Rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n```\n\n### 2. 克隆项目\n\n```bash\ngit clone https://github.com/xjz6626/xjz-website.git\ncd xjz-website\n```\n\n### 3. 构建生产版本\n\n```bash\ncargo build --release\n```\n\n### 4. 创建systemd服务\n\n```bash\nsudo tee /etc/systemd/system/xjz-website.service > /dev/null << 'EOF'\n[Unit]\nDescription=XJZ Personal Website\nAfter=network.target\n\n[Service]\nType=simple\nUser=fedora\nWorkingDirectory=/home/fedora/xjz-website\nEnvironment=RUST_LOG=info\nEnvironment=PORT=8181\nEnvironment=HOST=127.0.0.1\nExecStart=/home/fedora/xjz-website/target/release/xjz_website\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nEOF\n```\n\n### 5. 启动服务\n\n```bash\nsudo systemctl daemon-reload\nsudo systemctl enable xjz-website\nsudo systemctl start xjz-website\nsudo systemctl status xjz-website\n```\n\n### 6. 配置防火墙\n\n```bash\n# 开放端口（如果使用防火墙）\nsudo firewall-cmd --permanent --add-port=8181/tcp\nsudo firewall-cmd --reload\n\n# 或者允许HTTP/HTTPS（推荐通过反向代理）\nsudo firewall-cmd --permanent --add-service=http\nsudo firewall-cmd --permanent --add-service=https\nsudo firewall-cmd --reload\n```\n\n## Cloudflare 配置\n\n### 1. 域名配置\n\n1. 登录 [Cloudflare Dashboard](https://dash.cloudflare.com)\n2. 添加你的域名\n3. 按照提示更改域名服务器到Cloudflare\n\n### 2. DNS 记录配置\n\n添加以下DNS记录：\n\n```\n类型: A\n名称: @（或你的子域名）\n内容: 你的服务器IP地址\n代理状态: 已代理（橙色云朵）\nTTL: 自动\n```\n\n如果使用子域名：\n```\n类型: A\n名称: www\n内容: 你的服务器IP地址\n代理状态: 已代理（橙色云朵）\n```\n\n### 3. SSL/TLS 配置\n\n1. 进入 `SSL/TLS` > `概述`\n2. 选择加密模式：`灵活` 或 `完全`\n3. 进入 `边缘证书`\n4. 开启 `始终使用HTTPS`\n5. 开启 `HSTS`\n\n### 4. 性能优化\n\n进入 `速度` 页面：\n- 开启 `自动缩小`（CSS、HTML、JavaScript）\n- 开启 `Brotli` 压缩\n- 开启 `火箭加载器`（可选）\n\n### 5. 页面规则（可选）\n\n创建页面规则来优化缓存：\n\n```\nURL: yourdomain.com/public/*\n设置:\n- 缓存级别: 缓存所有内容\n- 边缘缓存TTL: 1个月\n```\n\n```\nURL: yourdomain.com/api/*\n设置:\n- 缓存级别: 绕过\n```\n\n## 安全配置\n\n### 1. Cloudflare 安全设置\n\n进入 `安全性` 页面：\n- 设置安全级别：`中` 或 `高`\n- 开启 `机器人斗争模式`（可选）\n- 配置 `速率限制`（可选）\n\n### 2. 防火墙规则\n\n创建防火墙规则只允许Cloudflare IP访问：\n\n```bash\n# 获取Cloudflare IP列表并配置防火墙（可选）\ncurl -s https://www.cloudflare.com/ips-v4 | while read ip; do\n    sudo firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='$ip' port protocol='tcp' port='8181' accept\"\ndone\n\nsudo firewall-cmd --reload\n```\n\n## 监控和维护\n\n### 1. 查看日志\n\n```bash\n# 查看应用日志\nsudo journalctl -u xjz-website -f\n\n# 查看系统日志\nsudo journalctl -xe\n```\n\n### 2. 更新部署\n\n```bash\ncd /home/fedora/xjz-website\ngit pull origin main\ncargo build --release\nsudo systemctl restart xjz-website\n```\n\n### 3. 监控服务状态\n\n```bash\n# 检查服务状态\nsudo systemctl status xjz-website\n\n# 检查端口监听\nsudo ss -tlnp | grep :8181\n\n# 检查进程\nps aux | grep xjz_website\n```\n\n## 故障排除\n\n### 应用无法启动\n```bash\n# 检查编译错误\ncargo build --release\n\n# 检查权限\nsudo chown -R fedora:fedora /home/fedora/xjz-website\n\n# 检查日志\nsudo journalctl -u xjz-website --no-pager\n```\n\n### Cloudflare 问题\n- 检查DNS解析：`dig yourdomain.com`\n- 验证SSL证书：浏览器访问 `https://yourdomain.com`\n- 清除Cloudflare缓存：Dashboard > 缓存 > 清除所有内容\n\n### 性能优化\n- 启用 Cloudflare 的 `Argo Smart Routing`\n- 配置 `缓存规则` 提高静态资源缓存\n- 使用 `Cloudflare Analytics` 监控性能\n\n## 备份策略\n\n```bash\n# 创建备份脚本\ncat > /home/fedora/backup.sh << 'EOF'\n#!/bin/bash\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_DIR=\"/home/fedora/backups\"\nmkdir -p $BACKUP_DIR\n\n# 备份应用目录\ntar -czf $BACKUP_DIR/xjz-website_$DATE.tar.gz /home/fedora/xjz-website\n\n# 保留最近7天的备份\nfind $BACKUP_DIR -name \"xjz-website_*.tar.gz\" -mtime +7 -delete\nEOF\n\nchmod +x /home/fedora/backup.sh\n\n# 添加到定时任务（每天凌晨2点备份）\necho \"0 2 * * * /home/fedora/backup.sh\" | crontab -\n```",
      "excerpt": "- Fedora Server (推荐 Fedora 38+) - Rust 1.70+ - Git",
      "file_path": "DEPLOYMENT.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/DEPLOYMENT.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-27T07:04:22Z",
      "file_size": 4783,
      "reading_time": 14,
      "category": "Web开发",
      "tags": [
        "JavaScript",
        "Rust",
        "Web"
      ],
      "featured": true
    },
    {
      "id": "xjz-website-DEVELOPMENT",
      "title": "开发记录",
      "content": "# 开发记录\n\n## 项目概述\n\nXJZ个人网站 - 基于Rust + Axum构建的高性能个人网站系统\n\n## 开发历程\n\n### 2024-10-18\n\n#### 初始化项目\n- 创建Rust Axum项目结构\n- 设计基础路由系统\n- 实现静态文件服务\n\n#### GitHub API集成\n- 实现GitHub客户端 (`src/github/client.rs`)\n- 设计数据模型 (`src/github/models.rs`)\n- 创建数据管理器 (`src/github/manager.rs`)\n- 支持项目、文章、统计数据获取\n\n#### 前端模板系统\n- 使用Askama模板引擎\n- 创建响应式布局 (`templates/base.html`)\n- 实现各页面模板：\n  - `index.html` - 主页\n  - `projects.html` - 项目展示\n  - `blog.html` - 博客文章\n  - `about.html` - 个人介绍\n  - `resume.html` - 简历\n  - `contact.html` - 联系方式\n\n#### 动态数据系统\n- 实现API端点：\n  - `/api/projects` - 项目数据\n  - `/api/articles` - 文章数据\n  - `/api/stats` - 统计数据\n- 前端JavaScript类：\n  - `HomeProjectLoader` - 主页项目加载\n  - `GitHubProjectLoader` - 项目页面加载\n  - `BlogLoader` - 博客文章加载\n\n#### 前端优化\n- 替换所有硬编码静态内容为动态API数据\n- 优化CSS样式系统\n- 添加加载状态和错误处理\n- 实现响应式设计\n\n## 技术特点\n\n### 后端架构\n- **框架**: Axum (高性能异步Web框架)\n- **HTTP客户端**: Reqwest (异步HTTP请求)\n- **模板引擎**: Askama (编译时模板)\n- **序列化**: Serde (JSON处理)\n- **异步运行时**: Tokio\n\n### 前端特性\n- **纯HTML/CSS/JS**: 无框架依赖\n- **响应式设计**: 支持多设备\n- **动态加载**: API驱动的内容更新\n- **性能优化**: 最小化网络请求\n\n### API设计\n- RESTful API设计\n- JSON数据格式\n- 错误处理和状态码\n- 缓存友好的响应头\n\n## 代码质量\n\n### 错误处理\n- 统一的错误类型系统\n- API错误的优雅降级\n- 前端错误状态显示\n\n### 性能优化\n- 异步I/O操作\n- 静态文件缓存\n- 最小化API调用\n\n### 可维护性\n- 模块化代码结构\n- 清晰的职责分离\n- 文档化的API接口\n\n## 部署准备\n\n### 生产优化\n- Release模式编译\n- 静态资源压缩\n- 环境变量配置\n\n### 服务器要求\n- Linux环境\n- Rust编译环境\n- 反向代理(Nginx)\n- SSL证书支持\n\n## 未来改进\n\n### 功能扩展\n- [ ] 评论系统\n- [ ] 搜索功能\n- [ ] RSS订阅\n- [ ] 多语言支持\n\n### 性能优化\n- [ ] Redis缓存\n- [ ] CDN集成\n- [ ] 图片优化\n- [ ] PWA支持\n\n### 监控运维\n- [ ] 日志系统\n- [ ] 监控指标\n- [ ] 自动部署\n- [ ] 备份策略",
      "excerpt": "XJZ个人网站 - 基于Rust + Axum构建的高性能个人网站系统 - 创建Rust Axum项目结构 - 设计基础路由系统",
      "file_path": "DEVELOPMENT.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/DEVELOPMENT.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-27T07:04:22Z",
      "file_size": 2529,
      "reading_time": 6,
      "category": "Web开发",
      "tags": [
        "JavaScript",
        "Rust",
        "Web"
      ],
      "featured": true
    },
    {
      "id": "xjz-website-GITHUB_SETUP",
      "title": "GitHub API 配置说明",
      "content": "# GitHub API 配置说明\n\n## 配置GitHub Personal Access Token\n\n### 步骤1: 创建GitHub Token\n\n1. 访问 https://github.com/settings/personal-access-tokens/tokens\n2. 点击 \"Generate new token (classic)\"\n3. 设置名称：比如 \"xjz_website_api\"\n4. 选择权限（scopes）：\n   - ✅ `public_repo` - 访问公开仓库\n   - ✅ `read:user` - 读取用户信息\n5. 点击 \"Generate token\"\n6. **重要**：复制生成的token（只显示一次）\n\n### 步骤2: 配置Token\n\n在 `src/github/config.rs` 文件中，找到这一行：\n```rust\nlet hardcoded_token = \"YOUR_TOKEN_HERE\";\n```\n\n将 `\"YOUR_TOKEN_HERE\"` 替换为你刚才复制的token：\n```rust\nlet hardcoded_token = \"ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n```\n\n### 步骤3: 重启服务器\n\n```bash\ncargo run\n```\n\n启动时你会看到配置状态：\n```\n=== GitHub配置状态 ===\n用户名: xjz6626\nToken: 已配置 ✅\nAPI限制: 5000次/小时\n=====================\n```\n\n## API 限制对比\n\n- **无token**: 60次/小时\n- **有token**: 5000次/小时\n\n## 验证配置\n\n配置完成后，测试API：\n```bash\ncurl http://127.0.0.1:8181/api/update\ncurl http://127.0.0.1:8181/api/stats\n```\n\n应该能看到正确的项目数据而不是错误信息。",
      "excerpt": "1. 访问 https://github.com/settings/personal-access-tokens/tokens 2. 点击 \"Generate new token (classic)\" 3. 设置名称：比如 \"xjz_website_api...",
      "file_path": "GITHUB_SETUP.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/GITHUB_SETUP.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-27T07:04:22Z",
      "file_size": 1223,
      "reading_time": 3,
      "category": "Web开发",
      "tags": [
        "Rust",
        "Web"
      ],
      "featured": false
    },
    {
      "id": "xjz-website-SERVICE_MANAGEMENT",
      "title": "XJZ Website 系统服务管理",
      "content": "# XJZ Website 系统服务管理\n\n## 🎉 部署完成！\n\nXJZ个人网站已成功配置为Linux系统服务，现在可以在后台自动运行，并在系统重启后自动启动。\n\n## 📊 服务状态\n\n- **服务名称**: `xjz-website`\n- **运行端口**: `8181`\n- **工作目录**: `/home/xjz/workplace/xjz-website`\n- **可执行文件**: `/home/xjz/workplace/xjz-website/target/release/xjz_website`\n- **配置文件**: `/etc/systemd/system/xjz-website.service`\n\n## 🔧 常用管理命令\n\n### 查看服务状态\n```bash\nsudo systemctl status xjz-website\n```\n\n### 启动服务\n```bash\nsudo systemctl start xjz-website\n```\n\n### 停止服务\n```bash\nsudo systemctl stop xjz-website\n```\n\n### 重启服务\n```bash\nsudo systemctl restart xjz-website\n```\n\n### 启用开机自启（已配置）\n```bash\nsudo systemctl enable xjz-website\n```\n\n### 禁用开机自启\n```bash\nsudo systemctl disable xjz-website\n```\n\n### 查看实时日志\n```bash\nsudo journalctl -u xjz-website -f\n```\n\n### 查看最近日志\n```bash\nsudo journalctl -u xjz-website -n 50\n```\n\n## 🌐 访问地址\n\n- **本地访问**: http://localhost:8181\n- **局域网访问**: http://[你的内网IP]:8181\n\n## 📝 自动更新机制\n\n网站会自动检查和更新GitHub数据：\n- **更新频率**: 每1天自动检查一次\n- **触发方式**: 当访问API时自动检查数据是否过期\n- **数据内容**: 项目信息、README文档、用户统计等\n- **缓存策略**: 未过期时使用本地缓存，提高响应速度\n\n服务配置文件位于 `/etc/systemd/system/xjz-website.service`：\n\n```ini\n[Unit]\nDescription=XJZ Personal Website Server\nDocumentation=https://github.com/xjz6626/xjz-website\nAfter=network.target\n\n[Service]\nType=simple\nUser=xjz\nGroup=xjz\nWorkingDirectory=/home/xjz/workplace/xjz-website\nExecStart=/home/xjz/workplace/xjz-website/target/release/xjz_website\nRestart=always\nRestartSec=5\nStandardOutput=journal\nStandardError=journal\n\n# Environment\nEnvironment=RUST_LOG=info\n\n# Security settings\nNoNewPrivileges=true\nProtectSystem=strict\nProtectHome=false\nReadWritePaths=/home/xjz/workplace/xjz-website/data\nPrivateTmp=true\n\n# Network\nPrivateNetwork=false\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## 🔄 更新网站代码\n\n当你修改代码后，需要重新构建和重启服务：\n\n```bash\ncd /home/xjz/workplace/xjz-website\n\n# 构建新版本\ncargo build --release\n\n# 重启服务\nsudo systemctl restart xjz-website\n\n# 检查状态\nsudo systemctl status xjz-website\n```\n\n## 🔧 API测试\n\n### 查看统计数据\n```bash\ncurl http://localhost:8181/api/stats | jq .\n```\n\n### 强制更新GitHub数据\n```bash\ncurl http://localhost:8181/api/update\n```\n\n### 检查网站响应\n```bash\ncurl -I http://localhost:8181\n```\n\n## 🛡️ 防火墙配置（可选）\n\n如果需要外网访问，需要开放8181端口：\n\n### Fedora/CentOS (firewalld)\n```bash\nsudo firewall-cmd --permanent --add-port=8181/tcp\nsudo firewall-cmd --reload\n```\n\n### Ubuntu (ufw)\n```bash\nsudo ufw allow 8181/tcp\n```\n\n## 📋 故障排除\n\n### 服务无法启动\n1. 检查可执行文件权限：`ls -la /home/xjz/workplace/xjz-website/target/release/xjz_website`\n2. 查看详细错误日志：`sudo journalctl -u xjz-website -n 100`\n3. 检查端口是否被占用：`sudo netstat -tlnp | grep 8181`\n\n### SELinux权限问题 ⚠️\n如果看到 \"Permission denied\" 错误，可能是SELinux问题：\n\n**症状**: \n- 服务状态显示 `activating (auto-restart)`\n- 日志显示 `Permission denied` 和 `exit-code 203/EXEC`\n\n**解决方法**:\n```bash\n# 方法1: 使用修复脚本\n./fix_selinux.sh\n\n# 方法2: 手动修复\nsudo chcon -t bin_t /home/xjz/workplace/xjz-website/target/release/xjz_website\nsudo systemctl restart xjz-website\n```\n\n**验证修复**:\n```bash\n# 检查SELinux上下文 (应该显示 bin_t)\nls -Z /home/xjz/workplace/xjz-website/target/release/xjz_website\n\n# 检查服务状态 (应该显示 active (running))\nsudo systemctl status xjz-website\n```\n\n### GitHub API 401错误\n1. 检查Token是否过期\n2. 更新 `src/github/config.rs` 中的Token\n3. 重新构建并重启服务\n\n### 数据更新失败\n1. 检查网络连接：`curl -I https://api.github.com`\n2. 验证Token权限：需要 `public_repo` 和 `read:user` 权限\n3. 查看详细日志了解具体错误\n\n## ✅ 成功指标\n\n- ✅ 服务状态：`Active: active (running)`\n- ✅ 网站响应：返回200状态码\n- ✅ API正常：`/api/stats` 返回正确数据\n- ✅ GitHub集成：能正常获取仓库和文章数据\n- ✅ 开机自启：系统重启后自动运行\n\n## 🎯 后续优化建议\n\n1. 配置反向代理（Nginx）支持HTTPS\n2. 设置定期备份GitHub数据\n3. 添加监控和告警\n4. 优化API缓存策略\n5. 配置CDN加速静态资源\n\n恭喜！你的个人网站现在已经是一个专业的系统服务了！🚀",
      "excerpt": "XJZ个人网站已成功配置为Linux系统服务，现在可以在后台自动运行，并在系统重启后自动启动。 - **服务名称**: `xjz...",
      "file_path": "SERVICE_MANAGEMENT.md",
      "file_url": "https://github.com/xjz6626/xjz-website/blob/main/SERVICE_MANAGEMENT.md",
      "repo_name": "xjz-website",
      "repo_url": "https://github.com/xjz6626/xjz-website",
      "updated_at": "2025-10-27T07:04:22Z",
      "file_size": 4793,
      "reading_time": 14,
      "category": "Web开发",
      "tags": [
        "Rust",
        "Web"
      ],
      "featured": true
    },
    {
      "id": "bangmi-媒体中心搭建指南",
      "title": "项目背景与媒体中心搭建指南",
      "content": "# 项目背景与媒体中心搭建指南\n\n本文档是对项目主 README 的补充，聚焦为什么选择 Seedr.cc 作为云端下载中转，及在 Fedora + Jellyfin + Kodi 环境下搭建高质量媒体中心的可操作步骤与排错经验。\n\n---\n\n## 1. 为什么选择 Seedr（云端离线下载）\n\n### 1.1 核心痛点\n\n- 许多网络环境（校园网、公司网、公共 Wi‑Fi）对 P2P 流量有限制或屏蔽，导致 BT 下载速度极慢或无法连接。\n- 在家用网络环境中，运营商可能对 P2P 做限速或封堵。\n\n这些限制会让传统 qBittorrent/Transmission 等 P2P 下载在很多场景下不可用。\n\n### 1.2 Seedr 的解决思路\n\n采用“云端离线下载”策略：\n\n1. 本地脚本把磁力提交给 Seedr（通过 HTTPS API）。\n2. Seedr 在其数据中心完成 P2P 下载（高速、稳定）。\n3. 下载完成后，脚本通过 Seedr 提供的 HTTP 下载链接把文件取回本地（无需本地 P2P）。\n\n优点：绕过本地 P2P 限制，下载稳定且速度快；无须开端口或依赖本地网络质量。\n\n安全注意：Seedr 存储你的文件与种子任务，账户凭据应妥善保管，`config.json` 中的凭据请保存在本地且加入 `.gitignore`。\n\n---\n\n## 2. 总体架构（示意）\n\n- search_torrents.py → 发现新集并写入 `search_results.json`\n- download_bt.py → 登录 Seedr、上传磁力、等待完成、下载到 `anime/`、更新 `download_history.json`\n- Jellyfin（媒体服务器）或直接用 Samba 共享供 Kodi 访问\n\n实战中我们在服务器上运行 Jellyfin（提供 Web UI），但由于 Flatpak + Tailscale 环境下，Kodi 的 Jellyfin 插件在本环境中存在兼容问题，最终采用 Samba 直接共享媒体目录给 Kodi。\n\n---\n\n## 3. 在 Fedora 上配置媒体共享（推荐：Samba）\n\n下面假设媒体目录为：`/home/xjz/workplace/bangmi/anime`。\n\n### 3.1 安装 Samba\n\n```bash\nsudo dnf install -y samba\n```\n\n### 3.2 编辑 Samba 配置\n\n在 `/etc/samba/smb.conf` 的 `[global]` 段后添加共享：\n\n```ini\n[Anime]\n   comment = Anime Media Share\n   path = /home/xjz/workplace/bangmi/anime\n   read only = yes\n   guest ok = no\n   browsable = yes\n   writable = no\n```\n\n确保每个配置项在单独的一行，不要把注释写在同一行。\n\n### 3.3 创建 Samba 用户与密码\n\n用户需要是系统用户（例如 `xjz`），然后为 Samba 添加密码：\n\n```bash\nsudo smbpasswd -a xjz\n```\n\n### 3.4 启动并启用 Samba 服务\n\n```bash\nsudo systemctl enable --now smb.service\nsudo systemctl enable --now nmb.service\n```\n\n### 3.5 SELinux: 允许共享家目录并设置上下文\n\n如果系统开启了 SELinux，需要允许 Samba 访问家目录并修正目录上下文：\n\n```bash\nsudo setsebool -P samba_enable_home_dirs on\nsudo setsebool -P allow_samba_user_share on\nsudo restorecon -Rv /home/xjz/workplace/bangmi/anime\n```\n\n如果 Samba 仍然无法访问，请检查 `ausearch -m avc -ts recent` 或 `journalctl -e` 中的 SELinux 拒绝消息。\n\n### 3.6 防火墙（如果启用 firewalld）\n\n允许 Samba 服务或给 Tailscale 接口放通：\n\n```bash\nsudo firewall-cmd --add-service=samba --permanent\nsudo firewall-cmd --reload\n# 或者允许特定接口（示例：tailscale0）\nsudo firewall-cmd --zone=trusted --add-interface=tailscale0 --permanent\nsudo firewall-cmd --reload\n```\n\n---\n\n## 4. Kodi 端配置与画质（缩放）优化\n\n在 Kodi 中直接挂载 SMB 源（路径示例）：\n\n- 协议：Windows 网络 (SMB)\n- 服务器：`100.117.113.106`（你的 Tailscale IP）\n- 共享名：`Anime`\n- 用户/密码：在第 3.3 步设置的 Samba 用户\n\n添加为视频源并设置内容类型为 TV 剧集。\n\n### 4.1 关键画质设置（放大算法）\n\n在 Kodi 播放时：\n\n1. 打开“播放控件” → 进入“视频设置”。\n2. 找到 “Video scaling method”（视频缩放/采样方式）。\n3. 将其从默认（通常为 Bilinear）改为 `Lanczos3-optimized` 或 `Lanczos`。\n\nLanczos 系列算法在将 1080p 放大到 4K 时能保留更多细节，显著改善模糊问题。\n\n（提示）可将该设置设为所有媒体的默认值以免每次手动切换。\n\n---\n\n## 5. 常见问题与排查建议\n\n- **Jellyfin 插件在 Kodi 上不显示媒体**：Flatpak + Tailscale 的组合可能导致插件无法访问底层文件路径。推荐绕过插件直接使用 Samba 或让 Jellyfin 作为备份索引工具而不作为 Kodi 的主数据源。\n- **权限错误（无法读取文件）**：检查文件所有权与权限，确保 `User`（运行 Kodi 或 Samba 的账号）对 `/home/xjz/workplace/bangmi/anime` 有读取权限：\n\n```bash\nsudo chown -R xjz:xjz /home/xjz/workplace/bangmi/anime\nsudo chmod -R 755 /home/xjz/workplace/bangmi/anime\n```\n\n- **SELinux 拒绝访问**：使用 `ausearch -m avc -ts today` 或 `journalctl -t setroubleshoot` 查看拒绝日志，按需调整 `setsebool` 或 `restorecon`。\n- **防火墙阻断**：使用 `sudo firewall-cmd --list-all` 检查区域与接口绑定。\n\n---\n\n## 6. 安全与运维小贴士\n\n- `config.json` 包含 Seedr/服务凭据，已加入 `.gitignore`，不要将其上传到公开仓库。备份真实配置为 `config.json.local`（仅本地保存）。\n- 定期清理 `anime/` 中的旧文件以节省磁盘，或配置 Jellyfin 的自动清理规则。\n- 对于自动运行的 `bangmi_scheduler.py`，建议使用 systemd（已在主 README 给出示例），并把日志输出到 `scheduler.log` 以便排错。\n\n---\n\n## 7. 常用命令速查\n\n```bash\n# Samba 安装与启动\nsudo dnf install -y samba\nsudo systemctl enable --now smb.service nmb.service\n\n# 检查 SELinux 的相关布尔值\nsestatus\nsudo getsebool -a | grep samba\n\n# 修改目录上下文\nsudo restorecon -Rv /home/xjz/workplace/bangmi/anime\n\n# 查看 Samba 状态与日志\nsudo systemctl status smb.service\nsudo journalctl -u smb.service -n 200 --no-pager\n\n# Kodi 上测试播放（客户端）: 通过 GUI 添加 SMB 源\n```\n",
      "excerpt": "本文档是对项目主 README 的补充，聚焦为什么选择 Seedr.cc 作为云端下载中转，及在 Fedora + Jellyfin + Kodi 环境下搭建...",
      "file_path": "媒体中心搭建指南.md",
      "file_url": "https://github.com/xjz6626/bangmi/blob/main/媒体中心搭建指南.md",
      "repo_name": "bangmi",
      "repo_url": "https://github.com/xjz6626/bangmi",
      "updated_at": "2025-10-24T03:19:18Z",
      "file_size": 5957,
      "reading_time": 14,
      "category": "技术文档",
      "tags": [
        "JavaScript",
        "Rust"
      ],
      "featured": true
    },
    {
      "id": "fedora-workstation-server-guide-Fedora Workstation 服务器化配置终极指南",
      "title": "**Fedora Workstation 服务器化配置终极指南**",
      "content": "# **Fedora Workstation 服务器化配置终极指南**\n\n## **简介**\n\n本文档旨在记录将一台全新的Fedora Workstation（以Fedora 42/43为例）转变为一台功能齐全、稳定可靠、可7x24小时远程管理的服务器的完整过程。本文档覆盖了从基础配置到高级排错的所有关键步骤，特别适合将较新的消费级笔记本改造为个人服务器的场景。\n\n## **零、前期准备**\n\n1. **硬件**: 一台已成功安装Fedora Workstation的笔记本电脑。  \n2. **网络**: 能够连接到互联网（有线或无线）。  \n3. **工具**: 一台用于远程连接的主力电脑，以及SSH客户端（如Kitty, Windows Terminal, PuTTY等）。\n\n## **一、系统初始化与基础配置**\n\n这是在新系统上要做的第一件事，确保所有组件都处于最新的安全状态，并安装一些必备的“瑞士軍刀”工具。\n\n### **1.1 全面更新系统**\n\n打开终端（Terminal），执行以下命令，将所有已安装的软件包更新到最新版本。-y参数会自动确认所有提示。\n\nsudo dnf update \\-y\n\n### **1.2 安装核心命令行工具**\n\n安装一些您未来一定会用到的基础工具，以提高工作效率。\n\n* vim / nano: 强大的文本编辑器（任选其一或都安装）。  \n* htop: 一个交互式的、更美观的系统进程监视器。  \n* git: 全球最流行的版本控制系统。\n\nsudo dnf install vim nano htop git \\-y\n\n## **二、核心服务器功能配置**\n\n这一部分是将您的笔记本电脑转变为一台真正“服务器”的关键。\n\n### **2.1 配置SSH远程访问**\n\nSSH (Secure Shell) 是远程命令行管理的基石。配置好后，您就可以合上笔记本盖子，在任何地方通过网络控制它。\n\n1. **安装SSH服务器软件** (Workstation版可能不默认安装):  \n   sudo dnf install openssh-server \\-y\n\n2. **启动SSH服务并设置为开机自启**:  \n   \\# 立即启动sshd服务  \n   sudo systemctl start sshd\n\n   \\# 设置为每次开机都自动运行 (非常重要！)  \n   sudo systemctl enable sshd\n\n3. 为SSH配置防火墙:  \n   Fedora默认开启了firewalld防火墙。我们需要明确地允许外部通过SSH连接进来。  \n   \\# \\--permanent 表示这条规则在重启后依然有效  \n   sudo firewall-cmd \\--add-service=ssh \\--permanent\n\n   \\# 重新加载防火墙规则，让新规则立即生效  \n   sudo firewall-cmd \\--reload\n\n   *如果提示Warning: ALREADY\\_ENABLED: ssh，这是正常现象，说明该规则已存在。*  \n4. 获取服务器的内网IP地址:  \n   您需要用这个地址来连接服务器。  \n   ip a\n\n   在输出中找到您的有线网卡(enp...)或无线网卡(wlp...)，记下 inet 后面的那个**内网IP地址**（通常是 192.168.x.x 格式）。现在，您就可以在另一台电脑的终端里使用 ssh your\\_username@\\<内网IP地址\\> 来远程登录了。\n\n### **2.2 配置服务器电源管理（合盖不休眠）**\n\n作为服务器，它必须24小时在线，不能因合上笔记本盖子而自动休眠。最新版的GNOME桌面隐藏了图形设置，我们通过修改配置文件来一劳一逸地解决。\n\n1. **理解配置文件机制**:  \n   * /usr/lib/systemd/logind.conf: 这是**系统默认**的配置文件，**不应修改**，否则会在系统更新时被覆盖。  \n   * /etc/systemd/logind.conf: 这是为**用户自定义**预留的配置文件。我们在这里的设置会覆盖掉系统默认设置。  \n2. **创建并编辑您的自定义配置文件**:  \n   sudo nano /etc/systemd/logind.conf\n\n3. **在该文件中添加以下内容**。这将确保无论笔记本处于何种状态（电池、插电、连接扩展坞），合上盖子都不会有任何动作。  \n   \\[Login\\]  \n   \\# 通用规则：只用电池时  \n   HandleLidSwitch=ignore\n\n   \\# 插电规则：连接AC电源时  \n   HandleLidSwitchExternalPower=ignore\n\n   \\# 底座规则：连接到扩展坞时  \n   HandleLidSwitchDocked=ignore\n\n4. **保存并退出** (Ctrl \\+ X, Y, Enter)。  \n5. **用最安全的方式应用设置——重启**:  \n   sudo reboot\n\n   重启后，无论您是在登录界面还是在桌面里，合上盖子服务器都将保持运行。\n\n## **三、远程管理与监控 (Cockpit)**\n\nCockpit是一个现代化的、基于网页的服务器管理后台，非常适合新手用来辅助管理。\n\n1. **安装 Cockpit**:  \n   sudo dnf install cockpit \\-y\n\n2. 启动并设置 Cockpit 开机自启:  \n   \\--now 参数会同时完成 start 和 enable 两个操作。  \n   sudo systemctl enable \\--now cockpit.socket\n\n3. **为 Cockpit 打开防火墙端口**:  \n   sudo firewall-cmd \\--add-service=cockpit \\--permanent  \n   sudo firewall-cmd \\--reload\n\n4. 访问方式:  \n   在您主力电脑的浏览器里，访问：  \n   https://\\<您的服务器内网IP地址\\>:9090  \n   （例如: https://192.168.124.16:9090）  \n   使用您在Fedora上创建的用户名和密码登录。（浏览器会提示安全警告，请选择“高级”并“继续前往”）。\n\n## **四、关键问题排错日志**\n\n本部分记录了在配置过程中遇到的典型问题及其最终解决方案。\n\n### **4.1 问题：有内网IP，但无法访问互联网 (DNS解析失败)**\n\n* **现象**: ping baidu.com 提示 Name or service not known，但 ping 8.8.8.8 成功。  \n* **诊断**: 网络路由通畅，但DNS服务器无法访问或配置错误。  \n* **解决方案**: 手动为网络连接指定一个可靠的公共DNS服务器。  \n  \\# 1\\. 查找当前活动的连接名  \n  nmcli connection show \\--active\n\n  \\# 2\\. 修改连接，将DNS设置为Google DNS和AliDNS (请将\"连接名\"替换为真实名称)  \n  sudo nmcli connection modify \"连接名\" ipv4.dns \"8.8.8.8 223.5.5.5\"  \n  sudo nmcli connection modify \"连接名\" ipv4.ignore-auto-dns yes\n\n  \\# 3\\. 重启网络连接以应用更改  \n  sudo nmcli connection down \"连接名\" && sudo nmcli connection up \"连接名\"\n\n### **4.2 问题：SSH连接时，nano等工具报错 Error opening terminal: xterm-kitty**\n\n* **现象**: 运行sudo nano ...等全屏应用时，因无法识别终端类型而失败。  \n* **诊断**: 服务器的终端信息数据库(terminfo)中，没有包含客户端（如Kitty终端）的定义。  \n* **一劳永逸的终极解决方案**: 从客户端提取定义，并安装到服务器的全局位置。  \n  1. **在【主力电脑】上**，生成终端定义文件：  \n     infocmp \\-x xterm-kitty \\> kitty.terminfo\n\n  2. **在【主力电脑】上**，将文件安全地复制到服务器：  \n     scp kitty.terminfo xjz@\\<服务器内网IP地址\\>:\\~/\n\n  3. **在【服务器】上**，以root权限编译并安装该定义，使其全局可用：  \n     sudo tic \\-x kitty.terminfo\n\n  4. 退出SSH并重新登录，问题解决。\n\n### **4.3 问题：scp文件传输时连接被立刻关闭 (Connection closed)**\n\n* **现象**: ssh可以正常登录，但scp命令失败。  \n* **诊断**: 服务器端的SSH服务配置中，没有启用SFTP文件传输子系统。  \n* **解决方案**: 修改SSH配置文件并重启服务。  \n  1. **在【服务器】上**，编辑SSH配置文件：  \n     sudo nano /etc/ssh/sshd\\_config\n\n  2. 在文件**最末尾**，添加或取消注释以下行：  \n     Subsystem sftp /usr/libexec/openssh/sftp-server\n\n  3. 保存并退出，然后**重启SSH服务**：  \n     sudo systemctl restart sshd\n\n## **五、让您的代码持续运行**\n\n* **方法A (简单快捷 \\- tmux)**: 适合调试和临时任务。  \n  \\# 安装  \n  sudo dnf install tmux \\-y  \n  \\# 新建会话  \n  tmux new \\-s my\\_session  \n  \\# (在会话里运行你的代码...)  \n  \\# 离开会话: 先按 Ctrl+b, 再按 d  \n  \\# 返回会话  \n  tmux attach \\-t my\\_session\n\n* **方法B (专业可靠 \\- systemd)**: 适合长期稳定运行的应用。  \n  1. 创建服务文件: sudo nano /etc/systemd/system/myapp.service  \n  2. 填入配置模板 (需修改User, WorkingDirectory, ExecStart):  \n     \\[Unit\\]  \n     Description=My App  \n     After=network.target\n\n     \\[Service\\]  \n     User=xjz  \n     WorkingDirectory=/home/xjz/my\\_project  \n     ExecStart=/usr/bin/python3 /home/xjz/my\\_project/main.py  \n     Restart=on-failure\n\n     \\[Install\\]  \n     WantedBy=multi-user.target\n\n  3. 启动并管理服务:  \n     sudo systemctl daemon-reload  \n     sudo systemctl enable \\--now myapp.service  \n     sudo systemctl status myapp.service\n\n## **六、外网访问与内网穿透**\n\n到目前为止，您的服务器只能在您宿舍的局域网（内网）中访问。本章将介绍如何让您从世界任何地方（外网）都能连接到您的服务器，即使您没有公网IP。\n\n### **6.1 方案A: 用于个人安全访问 \\- 部署 Tailscale**\n\n**背景**: Tailscale 是目前最简单、最安全的个人VPN解决方案。它会创建一个虚拟的加密局域网（Overlay Network），让您所有的设备无论身处何地，都好像在同一个房间里一样，可以直接通过一个永不改变的私有IP地址相互通信。所有流量都经过端到端加密，非常安全。\n\n**部署步骤**:\n\n1. 在【Fedora服务器】上安装并启动 Tailscale:  \n   打开终端，执行以下命令。脚本会自动检测您的系统并添加Tailscale的软件源。  \n   curl \\-fsSL \\[https://tailscale.com/install.sh\\](https://tailscale.com/install.sh) | sh\n\n   安装完成后，启动Tailscale并连接到您的账号网络：  \n   sudo tailscale up\n\n   执行后，终端会显示一个授权链接。请将此链接复制到您主力电脑的浏览器中打开，然后登录您的谷歌、微软或GitHub账号进行授权。  \n2. 在【主力设备】上安装 Tailscale:  \n   访问 Tailscale官网，为您的主力电脑（Windows, macOS）和手机（iOS, Android）下载并安装相应的客户端。安装后，用与服务器相同的账号登录。  \n3. 查找并使用 Tailscale IP:  \n   在您的服务器上运行以下命令，查看它独一无二的、永不改变的Tailscale IP地址：  \n   tailscale ip \\-4\n\n   您会得到一个 100.x.x.x 格式的IP地址。现在，无论您身在何处，只要您的主力设备也登录了Tailscale，您就可以直接通过这个IP地址进行所有操作，就像它们在同一个局域网里一样：  \n   * **SSH连接**: ssh xjz@\\<服务器的Tailscale IP\\>  \n   * **访问Cockpit**: https://\\<服务器的Tailscale IP\\>:9090\n\n### **6.2 方案B: 用于暴露公共服务 \\- 部署 Cloudflare Tunnel**\n\n**背景**: Cloudflare Tunnel 是一个免费且强大的内网穿透服务，非常适合将您服务器上的Web服务（如网站、API、WebUIs）安全地发布到公共互联网上，让任何人都可以通过一个域名访问。它无需公网IP，还能享受Cloudflare提供的DDoS防护和CDN加速。\n\n**部署步骤**:\n\n1. **准备工作**:  \n   * 您需要一个 [Cloudflare 账户](https://www.google.com/search?q=https://dash.cloudflare.com/sign-up)。  \n   * 您需要拥有一个自己的域名，并已将其添加到您的Cloudflare账户中进行管理。  \n2. 在【Fedora服务器】上安装 cloudflared:  \n   Cloudflare Tunnel的核心是一个名为 cloudflared 的客户端软件。  \n   \\# 添加Cloudflare的软件仓库  \n   sudo wget \\[https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-x86-64.rpm\\](https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-x86-64.rpm)  \n   \\# 使用dnf本地安装  \n   sudo dnf localinstall cloudflared-linux-x86-64.rpm \\-y\n\n3. 授权 cloudflared 客户端:  \n   执行以下命令，它会生成一个链接。  \n   cloudflared tunnel login\n\n   将此链接复制到您主力电脑的浏览器中打开，登录您的Cloudflare账户，并选择您要使用的域名进行授权。  \n4. **创建并配置隧道**:  \n   * **创建一个命名的隧道**:  \n     \\# 您可以把 my-server 替换成您喜欢的任何名字  \n     cloudflared tunnel create my-server\n\n     执行后，它会为您创建一个隧道，并生成一个包含密钥的.json文件，存放在 \\~/.cloudflared/ 目录下。  \n   * 创建配置文件:  \n     我们需要一个配置文件来告诉cloudflared如何将外部流量指向您服务器上的本地服务。  \n     \\# 创建并编辑配置文件  \n     nano \\~/.cloudflared/config.yml\n\n     将以下内容粘贴到文件中。这是一个示例，它会将 my-server.yourdomain.com 的访问请求，转发到您服务器本地的8080端口。  \n     tunnel: \\<你的Tunnel UUID\\>  \n     credentials-file: /home/xjz/.cloudflared/\\<你的Tunnel UUID\\>.json\n\n     ingress:  \n       \\- hostname: my-server.yourdomain.com  \n         service: http://localhost:8080  \n       \\- service: http\\_status:404\n\n     * **\\<你的Tunnel UUID\\>**: 请将这个替换为上一步创建隧道时生成的那个长长的ID。  \n     * **/home/xjz/**: 请确保这是您当前用户的正确家目录路径。  \n     * **https://www.google.com/search?q=my-server.yourdomain.com**: 请替换为您自己的域名。  \n     * **service**: http://localhost:8080 指向您本地运行的服务。  \n5. 为隧道创建DNS记录:  \n   执行以下命令，Cloudflare会自动为您的域名创建一个CNAME记录，指向您的隧道。  \n   cloudflared tunnel route dns my-server my-server.yourdomain.com\n\n6. 将隧道作为服务运行:  \n   为了让隧道能在后台持续运行并开机自启，我们需要将它安装成一个系统服务。  \n   \\# 使用root权限运行，让它安装成系统服务  \n   sudo cloudflared service install  \n   sudo systemctl start cloudflared  \n   sudo systemctl enable cloudflared\n\n7. **完成**！现在，全世界任何人都可以通过浏览器访问 https://my-server.yourdomain.com，Cloudflare的网络会自动将流量安全地隧道传输到您在宿舍的Fedora服务器上运行的服务。\n\n## **七、结语**\n\n恭喜您！您的Fedora服务器现已完全配置完毕，成为了一个稳定、安全、高效的现代化平台，随时可以承载您的奇思妙想。",
      "excerpt": "本文档旨在记录将一台全新的Fedora Workstation（以Fedora 42/43为例）转变为一台功能齐全、稳定可靠、可7x24小时远程...",
      "file_path": "Fedora Workstation 服务器化配置终极指南.md",
      "file_url": "https://github.com/xjz6626/fedora-workstation-server-guide/blob/main/Fedora Workstation 服务器化配置终极指南.md",
      "repo_name": "fedora-workstation-server-guide",
      "repo_url": "https://github.com/xjz6626/fedora-workstation-server-guide",
      "updated_at": "2025-10-24T03:19:10Z",
      "file_size": 14045,
      "reading_time": 33,
      "category": "技术文档",
      "tags": [
        "JavaScript",
        "Python"
      ],
      "featured": true
    },
    {
      "id": "E2000-memo-Arch Linux 嵌入式开发环境配置备忘录",
      "title": "**Arch Linux 嵌入式开发环境配置备忘录**",
      "content": "# **Arch Linux 嵌入式开发环境配置备忘录**\n\n本文档记录了从零开始，在 Arch Linux 主机上配置连接嵌入式开发板（E2000-Ubuntu）并共享网络的完整调试流程。\n\n## **第一部分：串口连接调试 (Serial Port)**\n\n目标：通过 minicom 或 picocom 等工具，成功通过串口连接到开发板的控制台。\n\n### **1.1 安装串口工具**\n\n\\# 安装经典的 minicom  \nsudo pacman \\-S minicom\n\n\\# 安装轻量级的 picocom (推荐)  \nsudo pacman \\-S picocom\n\n### **1.2 解决串口权限问题**\n\n直接连接通常会失败，提示 Permission denied。\n\n#### **1.2.1 确认设备名和用户组**\n\n首先，插入USB转串口设备，然后用 dmesg 查找设备名。\n\ndmesg | grep tty  \n\\# 输出通常会包含 ttyUSB0 或 ttyACM0\n\n接着，查看设备文件的权限。\n\nls \\-l /dev/ttyUSB0  \n\\# crw-rw---- 1 root uucp ...\n\n**关键点**：注意上面的用户组是 uucp。在很多其他发行版中是 dialout，但在我们的 Arch 系统上是 uucp。这意味着我们的用户需要被添加到 uucp 组。\n\n#### **1.2.2 将用户添加到 uucp 组**\n\n\\# 将当前用户添加到 uucp 组  \nsudo usermod \\-a \\-G uucp $USER\n\n**重要**：执行此命令后，必须**完全注销并重新登录**桌面环境，新的用户组权限才会生效。\n\n### **1.3 成功连接**\n\n完成权限配置后，使用 picocom 连接。\n\npicocom \\--baud 115200 /dev/ttyUSB0\n\n* **退出 Picocom**: 按 Ctrl+A 然后按 Ctrl+X。\n\n## **第二部分：共享主机网络给开发板**\n\n目标：让 Arch 主机通过 Wi-Fi 上网，然后通过有线网口将网络共享给开发板。\n\n### **2.1 识别网卡硬件与驱动问题**\n\n首先发现图形化网络设置中没有“有线连接”选项。\n\n#### **2.1.1 检查系统网络接口**\n\nip link show 命令的输出中没有 eth0 或 enp... 等有线网卡设备。\n\n#### **2.1.2 识别硬件型号**\n\n使用 lspci 查找硬件，发现系统未能加载驱动。\n\nlspci \\-k | grep \\-i ethernet \\-A 3  \n\\# 输出显示:  \n\\# 02:00.0 Ethernet controller: Motorcomm Microelectronics. YT6801 Gigabit Ethernet Controller  \n\\# (并且该条目下没有 \"Kernel driver in use\" 字样)\n\n**结论**: 系统缺少 Motorcomm YT6801 网卡的驱动。\n\n### **2.2 从 AUR 安装驱动**\n\nArch Linux 的官方仓库没有这个驱动，需要从 AUR (Arch User Repository) 安装。\n\n#### **2.2.1 安装 AUR 助手 yay (若无)**\n\nsudo pacman \\-S \\--needed base-devel git  \ngit clone \\[https://aur.archlinux.org/yay.git\\](https://aur.archlinux.org/yay.git)  \ncd yay  \nmakepkg \\-si  \ncd .. \\# 返回上级目录\n\n#### **2.2.2 安装内核头文件**\n\n编译内核驱动需要对应版本的头文件。假设使用的是 zen 内核。\n\n\\# uname \\-r  (可查看当前内核版本)  \nsudo pacman \\-S linux-zen-headers \\# 根据你的内核版本选择，例如 linux-headers\n\n#### **2.2.3 安装 DKMS 驱动**\n\nyay \\-S yt6801-dkms\n\n#### **2.2.4 加载并验证驱动**\n\nsudo modprobe yt6801  \nip link show\n\n此时应该能看到 enp2s0 等有线网卡接口出现了。重启电脑是确保驱动正确加载的最稳妥方法。\n\n### **2.3 配置 NetworkManager 共享**\n\n#### **2.3.1 安装 dnsmasq 依赖**\n\nNetworkManager 的共享功能依赖 dnsmasq 来提供 DHCP 服务。\n\nsudo pacman \\-S dnsmasq\n\n#### **2.3.2 重启 NetworkManager**\n\nsudo systemctl restart NetworkManager\n\n#### **2.3.3 在图形界面设置共享**\n\n1. 用网线连接两台电脑。  \n2. 进入“设置” \\-\\> “网络”。  \n3. 此时“有线连接”应该已出现。点击其旁边的齿轮图标 ⚙。  \n4. 进入 “IPv4” 选项卡，将 “Method” 设置为 “**与其他计算机共享**”。  \n5. 点击“应用”。\n\n### **2.4 手动配置防火墙 (iptables)**\n\n此时客户端能获取 IP (10.42.0.x)，DNS也能通，但 ping 不通外网。这是因为缺少 NAT 转发规则。\n\n#### **2.4.1 开启内核 IP 转发**\n\n\\# 临时生效  \nsudo sysctl net.ipv4.ip\\_forward=1  \n\\# 永久生效  \necho 'net.ipv4.ip\\_forward \\= 1' | sudo tee /etc/sysctl.d/99-forwarding.conf\n\n#### **2.4.2 添加 iptables 规则**\n\n\\# 规则1：允许已建立的连接通过  \nsudo iptables \\-A FORWARD \\-m conntrack \\--ctstate RELATED,ESTABLISHED \\-j ACCEPT\n\n\\# 规则2：允许从共享网口到外网的新连接  \nsudo iptables \\-A FORWARD \\-i enp2s0 \\-o wlan0 \\-j ACCEPT\n\n\\# 规则3：设置NAT地址伪装  \nsudo iptables \\-t nat \\-A POSTROUTING \\-s 10.42.0.0/24 \\-o wlan0 \\-j MASQUERADE\n\n**注意**：-i enp2s0 是你的有线网卡名，-o wlan0 是你的 Wi-Fi 网卡名。请根据 ip a 的实际输出进行调整。\n\n#### **2.4.3 永久保存 iptables 规则**\n\n\\# 安装用于保存规则的服务包 (安装时按 'y' 同意替换旧的 iptables)  \nsudo pacman \\-S iptables-nft\n\n\\# 保存当前生效的规则到文件  \nsudo iptables-save | sudo tee /etc/iptables/iptables.rules\n\n\\# 设置开机自启服务  \nsudo systemctl enable iptables.service\n\n## **第三部分：VS Code 远程 SSH 连接**\n\n目标：在 Arch 主机上使用 VS Code，通过 SSH 远程开发 E2000 板子。\n\n### **3.1 安装主机 SSH 客户端**\n\nVS Code 需要使用系统的 ssh 命令。\n\n\\# openssh 包同时提供了客户端和服务端  \nsudo pacman \\-S openssh\n\n### **3.2 安装 VS Code 扩展**\n\n在 VS Code 的扩展商店中，搜索并安装由 Microsoft 官方发布的 **Remote \\- SSH** 扩展。\n\n### **3.3 连接步骤**\n\n1. 点击 VS Code 左下角的绿色 \\>\\< 图标。  \n2. 选择 “Connect to Host...”。  \n3. 选择 “+ Add New SSH Host...”。  \n4. 输入连接命令：ssh root@10.42.0.102。  \n5. 选择默认的 SSH 配置文件保存。  \n6. 点击 “Connect”，在弹出的窗口中输入 root 用户的密码。  \n7. 连接成功后，左下角会显示 SSH: 10.42.0.102。\n\n至此，整个开发环境配置完成。",
      "excerpt": "本文档记录了从零开始，在 Arch Linux 主机上配置连接嵌入式开发板（E2000-Ubuntu）并共享网络的完整调试流程。 目...",
      "file_path": "Arch Linux 嵌入式开发环境配置备忘录.md",
      "file_url": "https://github.com/xjz6626/E2000-memo/blob/main/Arch Linux 嵌入式开发环境配置备忘录.md",
      "repo_name": "E2000-memo",
      "repo_url": "https://github.com/xjz6626/E2000-memo",
      "updated_at": "2025-10-24T03:18:53Z",
      "file_size": 5825,
      "reading_time": 14,
      "category": "技术文档",
      "tags": [],
      "featured": true
    },
    {
      "id": "E2000-memo-主板硬件连接说明文档",
      "title": "**主板硬件连接说明文档**",
      "content": "# **主板硬件连接说明文档**\n\n## **1\\. 概述**\n\n本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及串口调试工具。请在操作前仔细阅读本说明。\n\n## **2\\. 硬件接口总览**\n\n### **2.1 后置I/O接口**\n\n* **电源接口 (DC IN):** 用于连接电源适配器，为主板供电。  \n* **串口 (COM):** 两个标准的DB9公头串口，用于连接外部串口设备。  \n* **VGA接口:** 模拟视频输出接口，用于连接显示器。  \n* **HDMI接口:** 高清多媒体接口，用于连接高清显示设备。  \n* **USB 2.0/3.0接口:** 用于连接键盘、鼠标、U盘等USB外设。  \n* **网口 (LAN):** RJ45以太网接口，用于连接有线网络。  \n* **音频接口:** 包括音频输出（绿色）和麦克风输入（粉色）。\n\n### **2.2 板载接口与按钮**\n\n* **开机键:** 位于主板右上角，用于启动或关闭主板电源。  \n* **J15串口排针:** 位于MicroSD卡槽旁，用于连接TTL串口调试线。\n\n## **3\\. 连接步骤**\n\n### **3.1 电源连接与开机**\n\n1. **连接电源适配器:** 将电源适配器的DC输出端插入主板后置I/O面板上的 **电源接口**。  \n2. **启动系统:** 按下主板右上角的 **开机键**，系统将开始启动。\n\n### **3.2 串口调试连接 (适用于开发者)**\n\n此步骤用于底层系统调试，普通用户可跳过。\n\n1. **识别线序:**  \n   * **主板端:** 找到J15排针。  \n   * **USB转TTL模块端:** 识别GND (地)、TXD (发送)、RXD (接收) 引脚。  \n2. **连接线缆:**  \n   * 将杜邦线的一端连接到主板的 **J15** 排针上。  \n   * 将杜邦线的另一端连接到USB转TTL模块。**务必确保线序交叉连接正确**，连接方式如下：  \n     * 主板的 **GND** \\<--\\> 模块的 **GND** (黑色线)  \n     * 主板的 **TXD** \\<--\\> 模块的 **RXD** (红色线)  \n     * 主板的 **RXD** \\<--\\> 模块的 **TXD** (棕色线)\n\n**注意:** 串口通信的原理是发送端(TX)连接接收端(RX)。如果连接后无法通信，请检查接线或尝试对调模块端的TXD和RXD接线。\n\n3. **连接至计算机并配置SecureCRT:**  \n   * 将USB转TTL模块插入计算机的USB端口，系统会自动识别COM端口。  \n   * 打开 **SecureCRT** 软件，创建一个新的Serial（串口）会话。  \n   * 在会话设置中，**Port** 会自动识别，**Baud rate** (波特率) 设置为 **115200**，其余配置项保持默认。  \n   * 连接会话后，即可开始进行串口调试。\n\n### **3.3 通过网络共享为开发板提供网络 (Windows)**\n\n此步骤用于将您Windows电脑的网络连接共享给开发板，使其能够访问互联网。\n\n1. **物理连接:**  \n   * 使用一根网线，将开发板的 **网口(LAN)** 与您Windows电脑的 **以太网口** 直接连接。  \n   * 确保您的Windows电脑已通过其他方式（如Wi-Fi或另一个以太网口）连接到互联网。  \n2. **打开网络连接设置:**  \n   * 在Windows上，按下 Win \\+ R 键打开“运行”对话框。  \n   * 输入 ncpa.cpl 并按回车，这将打开“网络连接”窗口。  \n3. **配置网络共享:**  \n   * 在“网络连接”窗口中，找到您电脑用于上网的网络适配器（例如，名为“WLAN”或“Wi-Fi”的无线网络连接）。  \n   * 右键单击该适配器，选择 **“属性”**。  \n   * 切换到 **“共享”** 选项卡。  \n   * 勾选 **“允许其他网络用户通过此计算机的Internet连接来连接”** 复选框。  \n   * 在 **“家庭网络连接”** 的下拉菜单中，选择连接到开发板的那个以太网适配器（例如，名为“以太网”）。  \n   * 点击 **“确定”** 保存设置。Windows会自动为连接开发板的那个以太网口配置IP地址（通常是192.168.137.1）。  \n4. **配置并验证开发板网络:**  \n   * 启动开发板，进入其操作系统（Ubuntu）。  \n   * 将网络设置为 **自动获取IP地址 (DHCP)**。  \n   * 在终端中执行以下命令查看获取到的IP地址：  \n     ip a\n\n     在返回的信息中，您应该能看到一个形如 192.168.137.x 的IP地址。  \n   * 执行以下命令测试网络是否可用：  \n     ping baidu.com\n\n     如果看到有连续的数据返回，说明开发板已成功通过您的电脑连接到互联网。\n\n### **3.4 使用 VS Code 通过 SSH 远程开发**\n\n此步骤让您可以在熟悉的 VS Code 环境中直接对开发板上的文件进行编辑、编译和调试。\n\n1. **确认开发板 SSH 服务状态:**  \n   * 首先需要确保开发板已连接到网络（参考 3.3 节）。  \n   * 开发板通常已预装 SSH 服务。您可以在开发板的 Ubuntu 终端中，执行以下命令来检查其运行状态：  \n     sudo systemctl status ssh\n\n   * 如果服务未运行，可以使用 sudo systemctl start ssh 命令启动它。  \n2. **在 VS Code 中安装 \"Remote \\- SSH\" 扩展:**  \n   * 在您的 Windows 电脑上打开 VS Code。  \n   * 点击左侧活动栏的 **扩展** 图标 (Extensions)。  \n   * 在搜索框中输入 Remote \\- SSH。  \n   * 找到由 Microsoft 发布的官方扩展并点击 **安装 (Install)**。  \n3. **配置 SSH 连接:**  \n   * 安装扩展后，左侧活动栏会出现一个新的 **远程资源管理器** 图标 (Remote Explorer)。点击它。  \n   * 在下拉菜单中确保选中了 \"SSH\"。  \n   * 点击 \"SSH\" 标题栏旁边的 **“+”** 加号图标（新建远程连接）。  \n   * 在弹出的输入框中，输入连接命令，格式为 ssh username@ip\\_address。  \n     * username 是您在开发板 Ubuntu 系统上的用户名。  \n     * ip\\_address 是您在上一步中通过 ip a 命令获取到的 IP 地址 (例如 192.168.137.58)。  \n     * 示例: ssh myuser@192.168.137.58  \n   * 按回车后，选择第一个推荐的 SSH 配置文件进行保存。  \n4. **连接到开发板:**  \n   * 配置完成后，您将在远程资源管理器的列表中看到新添加的开发板主机。  \n   * 将鼠标悬停在该主机上，然后点击右侧出现的 **连接到主机** 图标（一个文件夹带一个加号的图标）。  \n   * VS Code 将打开一个新窗口并尝试连接。首次连接时会询问目标系统的平台类型，选择 **Linux**。  \n   * 在弹出的输入框中，输入您在开发板上的用户密码。  \n   * 连接成功后，VS Code 左下角会显示 SSH: \\[ip\\_address\\]，表示您已成功连接。  \n5. **开始开发:**  \n   * 连接成功后，点击 **文件 (File) \\> 打开文件夹 (Open Folder...)**，您可以直接浏览并打开开发板上的任意项目文件夹，像在本地一样进行开发了。\n\n## **4\\. 常用命令**\n\n### **4.1 关机**\n\n在终端中执行以下命令可以安全地关闭系统：\n\npoweroff\n\n### **4.2 重启**\n\n在终端中执行以下命令可以重启系统：\n\nreboot\n\n## **5\\. 注意事项**\n\n1. **环境隔离:** 尽量在 Docker 容器下使用项目指定的软件版本进行开发和测试，以避免环境污染和版本冲突。  \n2. **安全操作:** 切勿在 root 用户下运行来源不明的脚本或程序，以防系统被恶意破坏或数据泄露。\n\n\n![alt text](5bbbbdadca37c4d8ce03fc3af55f9103_720.jpg)\n![alt text](7df655a509c9c7f4f3b2f3d6f4af25ac_720.jpg)\n![alt text](64b549c97d4cca18e9fc1ce5b897ba53_720.jpg)\n![alt text](6023fcde6108ddd394eaf99b0cab18ea_720.jpg)",
      "excerpt": "本文档旨在为用户提供清晰、准确的硬件连接指导，确保用户能够正确、安全地为指定主板连接电源、外部设备及...",
      "file_path": "主板硬件连接说明文档.md",
      "file_url": "https://github.com/xjz6626/E2000-memo/blob/main/主板硬件连接说明文档.md",
      "repo_name": "E2000-memo",
      "repo_url": "https://github.com/xjz6626/E2000-memo",
      "updated_at": "2025-10-24T03:18:53Z",
      "file_size": 7462,
      "reading_time": 15,
      "category": "技术文档",
      "tags": [],
      "featured": true
    }
  ],
  "user_stats": {
    "username": "xjz6626",
    "total_repos": 7,
    "total_stars": 0,
    "total_forks": 0,
    "followers": 0,
    "following": 1,
    "public_gists": 0,
    "avatar_url": "https://avatars.githubusercontent.com/u/95295959?v=4",
    "bio": null,
    "location": null,
    "blog": "",
    "company": null,
    "created_at": "2021-11-30T14:18:28Z",
    "updated_at": "2025-10-17T12:54:41Z"
  },
  "language_stats": null,
  "last_updated": "2025-10-28T10:44:49.175073143Z",
  "next_update": "2025-10-29T10:44:49.175073143Z"
}